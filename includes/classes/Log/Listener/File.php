<?php

/**
 * A log listener that writes to a file. Writes log entries (by default in
 * JSON format) to files in a directory based on the name of the log. For
 * example, anything written to the 'app' log gets written to a file called
 * 'app.log' in the directory passed to the constructor.
 * Log files are rotated out automatically.
 */
class Octopus_Log_Listener_File {

	private $logDir;
	private $maxFileSize;
	private $rotationDepth = 5;
	private $logFiles = array();
	private $extension = '.log';
	private $formatter = array('Octopus_Log', 'formatJson');
	private $lastFailureWrite = 0;

	private static $writeFailureFile = null;

	/**
	 * Creates a new listener that creates log files in the given directory.
	 * @param $logDir Directory in which to create log files. If not specified,
	 * the LOG_DIR option is used. If LOG_DIR is not set, a directory called
	 * 'log' in the app's private dir is used.
	 */
	public function __construct($logDir = null) {

		$this->maxFileSize = 1024 * 1024 * 5; // 5M

		if ($logDir === null) {
			$logDir = get_option('LOG_DIR');
			if (!$logDir) {
				$logDir = get_option('OCTOPUS_PRIVATE_DIR') . 'log/';
			}
		}

		$this->logDir = $logDir;
	}

	public function getExtension() {
		return $this->extension;
	}

	/**
	 * Sets the extension used for files generated by this logger.
	 */
	public function setExtension($ext) {
		$this->extension = ($ext ? start_in('.', $ext) : '');
	}

	/**
	 * @return Function The callable used to format log entries for this
	 * logger. Defaults to Octopus_Log::formatJson
	 */
	public function getFormatter() {
		return $this->formatter;
	}

	/**
	 * Sets the formatter function used to format entries for this logger.
	 * @param Function $formatter Formatting function. Receives args like this:
	 *
	 *	function my_formatter($message, $log, $level, $timestamp, $stackTrace);
	 *
	 */
	public function setFormatter($formatter) {
		$this->formatter = $formatter;
	}

	/**
	 * @return String The full path to the file being written to.
	 */
	public function getLogFile($log) {

		if (isset($this->logFiles[$log])) {
			return $this->logFiles[$log];
		}

		$file = $log;

		$ext = $this->getExtension();
		if ($ext) {
			$file = preg_replace('/' . preg_quote($ext, '/') . '$/', '', $file);
		}

		$file = preg_replace('/[^a-z0-9\._]/i', '-', $file);
		$file = preg_replace('/-{2,}/', '-', $file);
		$file = trim($file, '-');

		return (
			$this->logFiles[$log] =
				rtrim($this->logDir, '/') . '/' .
				ltrim($file, '/') .
				$ext
		);
	}

	/**
	 * @return Number The maximum allowed log file size (in bytes).
	 * @see ::setMaxFileSize
	 */
	public function getMaxFileSize() {
		return $this->maxFileSize;
	}

	/**
	 * Sets the maximum allowed file size for log files generated by this
	 * class. Note that in practice a log file might be bigger than this,
	 * but once it hits this threshold no further messages will be written to
	 * that file.
	 */
	public function setMaxFileSize($size) {
		$this->maxFileSize = $size;
	}

	/**
	 * @return The max # of rotation files to keep (in addition to the primary
	 * log file).
	 */
	public function getRotationDepth() {
		return $this->rotationDepth;
	}

	/**
	 * Sets the # of files (in addition to the primary one) to keep when
	 * logging. Once a log file hits the size specified by ::getMaxFileSize,
	 * It gets renamed to 'file.1.log', with any existing rotation files
	 * being renamed down the line (so the old 'file.1.log' becomes
	 * 'file.2.log', the old 'file.2.log' becomes 'file.3.log', etc.).
	 */
	public function setRotationDepth($depth) {
		$this->rotationDepth = $depth;
	}

	/**
	 * Writes a message to this logger.
	 * @param $id Unique message id.
	 * @param $message The message to write
	 * @param $log The name of the log being written
	 * @param $level The level of the message.
	 * @param $index The incrementing index of this write.
	 * @see Octopus_Log::write
	 * @return Boolean Whether the write succeeded.
	 */
	public function write($id, $message, $log, $level, $index) {

		$time = microtime(true);

		$file = $this->getLogFile($log);

		if (is_file($file)) {

			$size = @filesize($file);

			if ($size > $this->maxFileSize) {

				if (!$this->rotateLog($file, $failureReason)) {
					return $this->failed('rotate log files', $file, $failureReason);
				}

			}

		}

		$dir = dirname($file);
		if (!is_dir($dir)) {
			if (!@mkdir($dir, 0777, true)) {
				return $this->failed('create log directory', $dir);
			}
		}

		$handle = @fopen($file, 'a');

		if ($handle === false) {
			// Opening the file for writing failed, so fail silently
			return $this->failed('open log file for writing', $file);
		}

		if ($message instanceof Exception) {
			$trace = Octopus_Debug::getNiceBacktrace($message->getTrace());
			$message = Octopus_Debug::dumpToString($message, 'text', true);
		} else {

			if ($message instanceof Octopus_Debug_DumpedVars) {
				$message = (string)$message;
			}

			$trace = Octopus_Debug::getNiceBacktrace();
		}

		$entry = call_user_func($this->getFormatter(), $id, $message, $log, $level, $time, $trace, $index);

		fwrite($handle, $entry);
		fwrite($handle, ",\n");
		fclose($handle);

		// Ensure the file is 0666
		@chmod($file, 0666);

		return true;

	}

	/**
	 * @param Number $maxAge If the last write failure was more than this many
	 * seconds ago, it is ignored and false is returned. If this is zero, the
	 * last write failure is returned no matter what.
	 * @return Array|Boolean Array describing the last write failure or false
	 * if there wasn't any.
	 */
	public static function getLastWriteFailure($maxAge = 30) {

		$file = self::getWriteFailureFile();

		if (!is_file($file)) {
			return false;
		}

		if ($maxAge && time() - filemtime($file) > $maxAge) {
			return false;
		}

		$contents = file_get_contents($file);
		return json_decode($contents);

	}

	/**
	 * Reads a log file and returns an array of log entries.
	 * @param  Mixed $file Filename to open.
	 * @return Mixed An Array of log items on success or false on failure.
	 */
	public static function readFile($file) {

		$contents = @file_get_contents($file);
		if ($contents === false) return false;

		$contents = preg_replace('/(^[\s,]+|[\s,]+$)/', '', $contents);
		$contents = @json_decode('[' . $contents . ']', true);

		return is_array($contents) ? $contents : false;

	}

	/**
	 * When log writes/rotates fail, this updates a quicky file in /tmp
	 * noting that. octopus/tail can pick this up and tell you if log writes
	 * are failing.
	 * @return Boolean False
	 */
	private function failed($message, $file) {

		$now = time();

		// only write failure messages every 5 seconds
		if ($now - $this->lastFailureWrite < 5) {
			return;
		}

		$this->lastFailureWrite = $now;
		$failureFile = self::getWriteFailureFile();

		@file_put_contents(
			$failureFile,
			// NOTE: in my tests, json_encode() performance is slightly better
			// than serialize() performance
			json_encode(array(
				'source' => __FILE__,
				'message' => $message,
				'log_file' => $file,
				'time' => time(),
			))
		);

	}

	/**
	 * @return String The full path to the file where log write failure notices
	 * are written.
	 */
	private static function getWriteFailureFile() {

		if (self::$writeFailureFile) {
			return self::$writeFailureFile;
		}

		return (self::$writeFailureFile = (

			'/tmp/.' .
			preg_replace('/[^a-z0-9]/i', '_', __FILE__) .
			'.logfail'

		));


	}

	/**
	 * Rotates log files around $currentFile.
	 * @return Boolean true on success, false on failure.
	 */
	private function rotateLog($currentFile, &$failureReason) {

		$depth = $this->getRotationDepth();

		if (!$depth || $depth <= 0) {
			// no rotation - just remove the current file
			return @unlink($currentFile);
		}

		// Create a base for forming new log file names

		$stub = $currentFile;
		$ext = $this->getExtension();

		if ($ext) {
			$stub = preg_replace('/' . preg_quote($ext, '/') . '$/', '', $stub);
		}

		// find files in the format logname.number.extension
		$files = @glob($stub . '.*' . $ext);

		if ($files === false) {
			$failureReason = "Could not glob existing log files";
			return false;
		}

		// Clean up any files over the threshold

		foreach($files as $file) {

			if (!preg_match('/\.(\d+)\.log$/', $file, $m)) {
				continue;
			}

			$num = @intval($m[1]);

			if ($num >= $depth) {
				if (!@unlink($file)) {
					$failureReason = "unlink failed: $file";
					return false;
				}
			}

		}

		$zeroes = 3;

		// Rename existing files down the line
		for($i = $depth; $i >= 1; $i--) {

			$num = sprintf(".%0{$zeroes}d", $i);
			$file = $stub . $num . $ext;

			if (is_file($file)) {

				$newFile = $stub . sprintf(".%0{$zeroes}d", $i + 1) . $ext;

				if (!@rename($file, $newFile)) {
					$failureReason = "rename failed: $file -> $newFile";
					return false;
				}

			}

		}

		$newFile = $stub . sprintf(".%0{$zeroes}d", 1) . $ext;

		// Move the existing log file to .1.log
		if (!@rename($currentFile, $newFile)) {
			$failureReason = "rename failed: $file -> $newFile";
			return false;
		}

		return true;
	}

}
