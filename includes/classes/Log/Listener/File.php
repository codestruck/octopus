<?php

/**
 * A log listener that writes to a file. Manages log rotation and everything.
 */
class Octopus_Log_Listener_File {

	private $logDir;
	private $maxFileSize;
	private $rotationDepth = 2;
	private $logFiles = array();
	private $extension = '.log';
	private $formatter = array('Octopus_Log', 'formatJson');

	/**
	 * Creates a new listener that creates log files in the given directory.
	 * @param $logDir Directory in which to create log files. If not specified,
	 * the LOG_DIR option is used. If LOG_DIR is not set, a directory called
	 * 'log' in the app's private dir is used.
	 */
	public function __construct($logDir = null) {

		$this->maxFileSize = 1024 * 1024; // 1M

		if ($logDir === null) {
			$logDir = get_option('LOG_DIR');
			if (!$logDir) {
				$logDir = get_option('OCTOPUS_PRIVATE_DIR' . 'log/');
			}
		}

		$this->logDir = $logDir;
	}

	public function getExtension() {
		return $this->extension;
	}

	/**
	 * Sets the extension used for files generated by this logger.
	 */
	public function setExtension($ext) {
		$this->extension = ($ext ? start_in('.', $ext) : '');
	}

	/**
	 * @return Function The callable used to format log entries for this
	 * logger. Defaults to Octopus_Log::formatJson
	 */
	public function getFormatter() {
		return $this->formatter;
	}

	/**
	 * Sets the formatter function used to format entries for this logger.
	 * @param Function $formatter Formatting function. Receives args like this:
	 *
	 *	function my_formatter($message, $log, $level, $timestamp, $stackTrace);
	 *
	 */
	public function setFormatter($formatter) {
		$this->formatter = $formatter;
	}

	/**
	 * @return String The full path to the file being written to.
	 */
	public function getLogFile($log) {

		if (isset($this->logFiles[$log])) {
			return $this->logFiles[$log];
		}

		$file = strtolower($log);

		$ext = $this->getExtension();
		if ($ext) {
			$file = preg_replace('/' . preg_quote($ext, '/') . '$/', '', $file);
		}

		$file = preg_replace('/[^a-z0-9\._]/i', '-', $file);
		$file = preg_replace('/-{2,}/', '-', $file);
		$file = trim($file, '-');

		return (
			$this->logFiles[$log] =
				end_in('/', $this->logDir) .
				$file .
				$ext
		);

		return $this->logFile;
	}

	/**
	 * @return Number The maximum allowed log file size (in bytes).
	 * @see ::setMaxFileSize
	 */
	public function getMaxFileSize() {
		return $this->maxFileSize;
	}

	/**
	 * Sets the maximum allowed file size for log files generated by this
	 * class. Note that in practice a log file might be bigger than this,
	 * but once it hits this threshold no further messages will be written to
	 * that file.
	 */
	public function setMaxFileSize($size) {
		$this->maxFileSize = $size;
	}

	/**
	 * @return The max # of rotation files to keep (in addition to the primary
	 * log file).
	 */
	public function getRotationDepth() {
		return $this->rotationDepth;
	}

	/**
	 * Sets the # of files (in addition to the primary one) to keep when
	 * logging. Once a log file hits the size specified by ::getMaxFileSize,
	 * It gets renamed to 'file.1.log', with any existing rotation files
	 * being renamed down the line (so the old 'file.1.log' becomes
	 * 'file.2.log', the old 'file.2.log' becomes 'file.3.log', etc.).
	 */
	public function setRotationDepth($depth) {
		$this->rotationDepth = $depth;
	}

	/**
	 * Writes a message to this logger.
	 * @param $message The message to write
	 * @param $log The name of the log being written
	 * @param $level The level of the message.
	 * @see Octopus_Log::write
	 * @return Boolean Whether the write succeeded.
	 */
	public function write($message, $log, $level) {

		$file = $this->getLogFile($log);

		if (is_file($file)) {

			$size = @filesize($file);

			if ($size > $this->maxFileSize) {

				if (!$this->rotateLog($file, $failureReason)) {
					return false;
				}

			}

		}

		$dir = dirname($file);
		if (!is_dir($dir)) {
			if (!@mkdir(dirname($file), 0777, true)) {
				return false;
			}
		}

		$handle = @fopen($file, 'a');

		if ($handle === false) {
			// Opening the file for writing failed, so fail silently
			return false;
		}

		$entry = call_user_func($this->getFormatter(), $message, $log, $level, time(), $this->getStackTrace());

		fwrite($handle, $entry);
		fwrite($handle, ",\n");
		fclose($handle);

		// Ensure the file is 0666
		@chmod($file, 0666);

		return true;

	}

	private function getStackTrace() {
		return Octopus_Debug::saneBacktrace();
	}

	/**
	 * Rotates log files around $currentFile.
	 * @return Boolean true on success, false on failure.
	 */
	private function rotateLog($currentFile, &$failureReason) {

		$depth = $this->getRotationDepth();

		if (!$depth || $depth <= 0) {
			// no rotation - just remove the current file
			return @unlink($currentFile);
		}

		// Create a base for forming new log file names

		$stub = $currentFile;
		$ext = $this->getExtension();

		if ($ext) {
			$stub = preg_replace('/' . preg_quote($ext, '/') . '$/', '', $stub);
		}

		// find files in the format logname.number.extension
		$files = @glob($stub . '.*' . $ext);

		if ($files === false) {
			$failureReason = "Could not glob existing log files";
			return false;
		}

		// Clean up any files over the threshold

		foreach($files as $file) {

			if (!preg_match('/\.(\d+)\.log$/', $file, $m)) {
				continue;
			}

			$num = @intval($m[1]);

			if ($num >= $depth) {
				if (!@unlink($file)) {
					$failureReason = "unlink failed: $file";
					return false;
				}
			}

		}

		$zeroes = 3;

		// Rename existing files down the line
		for($i = $depth; $i >= 1; $i--) {

			$num = sprintf(".%0{$zeroes}d", $i);
			$file = $stub . $num . $ext;

			if (is_file($file)) {

				$newFile = $stub . sprintf(".%0{$zeroes}d", $i + 1) . $ext;

				if (!@rename($file, $newFile)) {
					$failureReason = "rename failed: $file -> $newFile";
					return false;
				}

			}

		}

		$newFile = $stub . sprintf(".%0{$zeroes}d", 1) . $ext;

		// Move the existing log file to .1.log
		if (!@rename($currentFile, $newFile)) {
			$failureReason = "rename failed: $file -> $newFile";
			return false;
		}

		return true;
	}

}

?>